Metadata-Version: 2.4
Name: pyhbm
Version: 2.0
Summary: Python Harmonic Balance Method library for nonlinear dynamics
Author: Tiago
License: MIT
Project-URL: Homepage, https://github.com/pyhbm/pyhbm
Project-URL: Repository, https://github.com/pyhbm/pyhbm
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: numpy>=1.20
Requires-Dist: scipy>=1.8
Requires-Dist: matplotlib>=3.5
Provides-Extra: dev
Requires-Dist: pytest>=7.0; extra == "dev"
Requires-Dist: pytest-cov>=4.0; extra == "dev"

# pyhbm

Python Harmonic Balance Method library for nonlinear dynamics analysis.

## Overview

pyhbm provides tools for solving nonlinear dynamical systems using the Harmonic Balance Method (HBM) with numerical continuation. It supports:

- Frequency domain analysis with arbitrary harmonic expansions
- Numerical continuation for tracking solutions across parameter ranges
- Both autonomous and non-autonomous systems
- Real and complex Fourier representations

## Installation

### Requirements
- Python >= 3.9
- numpy >= 1.20
- scipy >= 1.8
- matplotlib >= 3.5

### From PyPI
```bash
python -m pip install pyhbm
```

### For Development
```bash
python -m pip install -e .
```

### Install Dependencies Only
```bash
python -m pip install numpy scipy matplotlib
```

## Quick Start

```python
import numpy as np
from pyhbm import HarmonicBalanceMethod, FourierOmegaPoint, FirstOrderODE

# Define your dynamical system
class DuffingForced(FirstOrderODE):
    def __init__(self, c=0.01, k=1.0, beta=1.0, P=1.0):
        self.c = c
        self.k = k
        self.beta = beta
        self.P = P
        
    @property
    def dimension(self):
        return 2
    
    def compute_differential_equation(self, u, omega):
        x, y = u[0, 0], u[1, 0]
        dx = y
        dy = -self.k * x - self.beta * x**3 - self.c * y + self.P * np.cos(omega * self.t)
        return np.array([[dx], [dy]])

# Create solver
duffing = DuffingForced(c=0.009, k=1.0, beta=1.0, P=1.0)
solver = HarmonicBalanceMethod(
    first_order_ode=duffing, 
    harmonics=[1, 3, 5, 7, 9],
)

# Define initial guess
initial_omega = 0.0
first_harmonic = np.array([[1], [1j * initial_omega]])
static_amplitude = duffing.P / duffing.k
initial_guess = FourierOmegaPoint.new_from_first_harmonic(
    first_harmonic * static_amplitude, 
    omega=initial_omega
)
initial_reference_direction = FourierOmegaPoint.new_from_first_harmonic(
    first_harmonic, 
    omega=1
)

# Solve and continue
solution_set = solver.solve_and_continue(
    initial_guess=initial_guess,
    initial_reference_direction=initial_reference_direction,
    maximum_number_of_solutions=1000,
    angular_frequency_range=[0.0, 10],
    solver_kwargs={"maximum_iterations": 200, "absolute_tolerance": 1e-6},
    step_length_adaptation_kwargs={
        "base": 2,
        "initial_step_length": 0.1,
        "maximum_step_length": 2.0,
    }
)

# Plot results
solution_set.plot_FRF(degrees_of_freedom=0, xscale='log', yscale='log')
```

## Examples

The `examples/` directory contains several working examples:

| Example | Description |
|---------|-------------|
| `duffing_forced_nonautonomous/` | Forced Duffing oscillator |
| `duffing_conservative_autonomous/` | Conservative Duffing (autonomous) |
| `pendulum_forced_nonautonomous/` | Forced pendulum |
| `2dof_duffing/` | 2-DOF Duffing system |
| `linear_frequency_response/` | Linear system frequency response |
| `arch_beam_ssm/` | Arch beam SSM analysis |

Run an example:
```bash
cd examples/duffing_forced_nonautonomous
python main.py
```

## API Reference

### Core Classes

| Class | Description |
|-------|-------------|
| `HarmonicBalanceMethod` | Main solver for HBM with continuation |
| `SolutionSet` | Container for solution families |
| `FourierOmegaPoint` | Fourier representation with frequency |
| `Fourier` | Base Fourier coefficient class |

### Frequency Domain

| Class | Description |
|-------|-------------|
| `Fourier` | Base Fourier representation |
| `Fourier_Real` | Real-valued Fourier coefficients |
| `Fourier_Complex` | Complex-valued Fourier coefficients |
| `FourierOmegaPoint` | Combined Fourier and frequency |
| `FirstOrderODE` | Base class for dynamical systems |
| `FrequencyDomainFirstOrderODE` | Frequency domain ODE wrapper |

### Numerical Continuation

| Class | Description |
|-------|-------------|
| `NewtonRaphson` | Newton-Raphson corrector solver |
| `Predictor` | Base predictor class |
| `TangentPredictorOne` | First-order tangent predictor |
| `TangentPredictorTwo` | Second-order tangent predictor |
| `TangentPredictorRobust` | Robust tangent predictor |
| `StepLengthAdaptation` | Base step length adaptation |
| `ExponentialAdaptation` | Exponential step size adaptation |
| `BiExponentialAdaptation` | Bi-exponential adaptation |
| `OrthogonalParameterization` | Orthogonal correction method |

## License

MIT
